(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{407:function(v,_,t){"use strict";t.r(_);var a=t(26),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"http主要优化方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http主要优化方式"}},[v._v("#")]),v._v(" http主要优化方式")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("压缩")])]),v._v(" "),t("li",[t("strong",[v._v("缓存")])])]),v._v(" "),t("h2",{attrs:{id:"压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩"}},[v._v("#")]),v._v(" 压缩")]),v._v(" "),t("h3",{attrs:{id:"http压缩与uglify压缩区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http压缩与uglify压缩区别"}},[v._v("#")]),v._v(" http压缩与uglify压缩区别")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("uglify压缩js代码中的空格、空行，混淆代码指将过长变量名统一替换成简单字符")])]),v._v(" "),t("li",[t("p",[v._v("http压缩是将文件内容中重复的部分进行压缩，如html中重复的标签名，重复的部分越多，压缩质量越高")]),v._v(" "),t("p",[v._v("视频，音频相关的文件，压缩质量很低")]),v._v(" "),t("p",[v._v("压缩完是可以解压的，而不是删除内容")])])]),v._v(" "),t("h3",{attrs:{id:"压缩流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩流程"}},[v._v("#")]),v._v(" 压缩流程")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("客户端发出http请求文件时，请求头中的 "),t("code",[v._v("Accept-Encoding")]),v._v(" 字段告知服务器，自身支持哪种压缩格式")]),v._v(" "),t("p",[v._v("例："),t("code",[v._v("Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1")])]),v._v(" "),t("p",[v._v("q是权重 1最高")])]),v._v(" "),t("li",[t("p",[v._v("服务器收到请求后，根据请求头中的 "),t("code",[v._v("Accept-Encoding")]),v._v("  字段知道了客户端浏览器支持的压缩格式，如果有压缩，没有就不压缩。压缩完成后，写入文件，返回给客户端浏览器")]),v._v(" "),t("p",[v._v("并在 "),t("code",[v._v("response Header")]),v._v(" 中返回 "),t("code",[v._v("content-encoding")]),v._v(" 字段告知浏览器，文件是以什么样的格式进行压缩的，否则浏览器无法正确解析压缩过后的文件，会出现乱码")]),v._v(" "),t("p",[v._v("例："),t("code",[v._v("content-encoding: gzip")])]),v._v(" "),t("p",[v._v("node压缩格式一般是 "),t("code",[v._v("gzip、 deflate")])])])]),v._v(" "),t("h3",{attrs:{id:"压缩原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩原理"}},[v._v("#")]),v._v(" 压缩原理")]),v._v(" "),t("p",[v._v("压缩功能实现是使用node专用于做压缩的zlib模块，zlib模块压缩方式：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("同步压缩：等文件所有内容压缩完，在返回给客户端")])]),v._v(" "),t("li",[t("p",[v._v("流式压缩：一边压缩一边返回")]),v._v(" "),t("p",[v._v("实际上是借助"),t("strong",[v._v("转换流")]),v._v("的概念，将目标文件读取出来，经过转换流压缩，在返回给客户端。")]),v._v(" "),t("p",[t("code",[v._v("可读流.pipe(zlib.createGzip()).pipe(可写流)")])])])]),v._v(" "),t("h3",{attrs:{id:"压缩实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩实战"}},[v._v("#")]),v._v(" 压缩实战")]),v._v(" "),t("ol",[t("li",[v._v("webpack 的 devServer 中的 "),t("code",[v._v("compress")]),v._v(" 属性")])]),v._v(" "),t("h2",{attrs:{id:"缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),t("p",[v._v("缓存指，客户端浏览器请求服务器获取到资源后，同时会将资源复制一份缓存至本地硬盘中的一个文件内。")]),v._v(" "),t("p",[v._v("再次请求服务器同一资源时，会被服务器返回的信息告知从自己的缓存文件夹中获取即可。")]),v._v(" "),t("p",[v._v("这个交互过程实现了资源的缓存")]),v._v(" "),t("h3",{attrs:{id:"缓存的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存的方式"}},[v._v("#")]),v._v(" 缓存的方式")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("强制缓存")])]),v._v(" "),t("li",[t("strong",[v._v("对比缓存（协商缓存）")])]),v._v(" "),t("li",[t("strong",[v._v("指纹缓存")])])]),v._v(" "),t("h3",{attrs:{id:"强制缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[v._v("#")]),v._v(" 强制缓存")]),v._v(" "),t("h4",{attrs:{id:"什么是强制缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是强制缓存"}},[v._v("#")]),v._v(" 什么是强制缓存")]),v._v(" "),t("p",[v._v("客户端发起请求，服务器在返回资源的同时，在"),t("strong",[v._v("响应中")]),v._v("设置 "),t("code",[v._v("Cache-Control")]),v._v(" 或者 "),t("code",[v._v("Expires")]),v._v(" 告知客户端浏览器："),t("strong",[v._v("10秒之内")]),v._v("、或在"),t("strong",[v._v("规定日期之前")]),v._v("不要再找我了，从你的缓存文件夹中取！")]),v._v(" "),t("p",[v._v("走强制缓存时，响应状态码为200")]),v._v(" "),t("h4",{attrs:{id:"cache-control-与-expires-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-与-expires-区别"}},[v._v("#")]),v._v(" Cache-Control 与 Expires 区别")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("写法不同")]),v._v(" "),t("p",[t("code",[v._v("Cache-Control: max-age=10")])]),v._v(" "),t("p",[t("code",[v._v("Expires: Expires: Wed, 21 Oct 2015 07:28:00 GMT")])])]),v._v(" "),t("li",[t("p",[v._v("单位不同")]),v._v(" "),t("p",[v._v("Cache-Control 单位是秒，是"),t("strong",[v._v("相对时间")]),v._v("，表示多少秒之后")]),v._v(" "),t("p",[v._v("Expires 单位是UTC，也就是我们所说的"),t("strong",[v._v("格林威治时间")]),v._v("，指的是time中的"),t("strong",[v._v("世界时间标准")]),v._v("。是绝对时间，表示过期时间是什么时候。")])]),v._v(" "),t("li",[t("p",[v._v("权重不同")]),v._v(" "),t("p",[v._v("因为Expires是老版本设置， 设置Cache-Control 会覆盖掉 Expires")])])]),v._v(" "),t("h4",{attrs:{id:"强制缓存缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存缺点"}},[v._v("#")]),v._v(" 强制缓存缺点")]),v._v(" "),t("p",[v._v("服务器文件更新之后，在没有超过规定时间时，客户端浏览器仍会走缓存，访问旧文件")]),v._v(" "),t("h3",{attrs:{id:"对比缓存-协商缓存-304"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比缓存-协商缓存-304"}},[v._v("#")]),v._v(" 对比缓存（协商缓存）304")]),v._v(" "),t("h4",{attrs:{id:"什么是对比缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是对比缓存"}},[v._v("#")]),v._v(" 什么是对比缓存")]),v._v(" "),t("p",[v._v("客户端请求第一次时，服务器在response中设置 "),t("code",[v._v("Last-Modified")]),v._v(" ，告之客户端这个文件最新修改时间。")]),v._v(" "),t("p",[v._v("客户端下次再请求时，在request中会携带 "),t("code",[v._v("If-Modified-Since")]),v._v(" 这个时间戳标识，服务器比较标识，如果标识不同，证明后来又被修改过，返回新文件。否则告知客户端：文件没有变化，从缓存中去取吧。")]),v._v(" "),t("p",[v._v("走对比缓存时，"),t("strong",[v._v("响应状态码为304")])]),v._v(" "),t("h4",{attrs:{id:"对比缓存缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比缓存缺点"}},[v._v("#")]),v._v(" 对比缓存缺点")]),v._v(" "),t("ol",[t("li",[v._v("反复操作文件，虽然文件内容没变，但是最后修改时间改了。客户端不会走缓存。")]),v._v(" "),t("li",[v._v("cdn分发时间不同，会导致得到不一样的结果")])]),v._v(" "),t("h3",{attrs:{id:"指纹缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指纹缓存"}},[v._v("#")]),v._v(" 指纹缓存")]),v._v(" "),t("h4",{attrs:{id:"什么是指纹缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是指纹缓存"}},[v._v("#")]),v._v(" 什么是指纹缓存")]),v._v(" "),t("p",[v._v("首次接到请求后，摘要/加盐文件部分内容，生成唯一key，名为 "),t("code",[v._v("Etag")]),v._v(" 传给客户端。")]),v._v(" "),t("p",[v._v("客户端下次再请求同一文件时，在request中加入请求头 "),t("code",[v._v("If-None-Match")])]),v._v(" "),t("p",[v._v("服务器端收到后作比较，更加准确的判断文件是否被修改过，后续同对比缓存")]),v._v(" "),t("p",[v._v("例")]),v._v(" "),t("p",[t("code",[v._v('ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"')])]),v._v(" "),t("p",[t("code",[v._v('If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"')])]),v._v(" "),t("h4",{attrs:{id:"什么是md5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是md5"}},[v._v("#")]),v._v(" 什么是MD5")]),v._v(" "),t("p",[v._v("MD5是一种信息摘要算法，摘取文件部分内容。")]),v._v(" "),t("p",[v._v("MD5本来也不是作加密使用，而是用来"),t("strong",[v._v("校验数据的完整性")]),v._v("。")]),v._v(" "),t("p",[v._v("MD5不算是加密算法，因为摘要不代表全部内容，不可解密，不可反推，就是无论多大数据，经过算法运算后都是"),t("strong",[v._v("生成固定长度")]),v._v("的数据。")]),v._v(" "),t("p",[v._v("相同的内容摘要的结果相同。有一点不同，摘要的结果完全不同。")]),v._v(" "),t("h4",{attrs:{id:"使用md5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用md5"}},[v._v("#")]),v._v(" 使用MD5")]),v._v(" "),t("p",[t("code",[v._v("Crypto.createHash('md5').update('文件部分内容' + random() ).digest('base64')")])]),v._v(" "),t("p",[v._v("由于MD5大家都知道，很容易被猜到，所以在摘要时加一个随机数。")]),v._v(" "),t("h4",{attrs:{id:"什么是加盐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是加盐"}},[v._v("#")]),v._v(" 什么是加盐")]),v._v(" "),t("p",[v._v("使用 "),t("code",[v._v("sha1")]),v._v(" "),t("code",[v._v("sha256")]),v._v(" 这种加密算法，流程同MD5相同")]),v._v(" "),t("h3",{attrs:{id:"最佳实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[v._v("#")]),v._v(" 最佳实践")]),v._v(" "),t("p",[v._v("开启所有类型缓存，只要有一个失效，就算失效。")]),v._v(" "),t("p",[v._v("先"),t("strong",[v._v("强制缓存（200）")]),v._v("——再对比缓存和指纹缓存（两者有一个失效就算过期）")]),v._v(" "),t("p",[v._v("那么"),t("strong",[v._v("问题来了")]),v._v("，这样设置时，在强制缓存下，缓存没过期时，服务器端更改了文件，客户端不一样拿不到最新的文件吗。")]),v._v(" "),t("p",[v._v("我们所说的缓存多用于静态资源和图片（static文件夹），对于经常改编的js逻辑，在正式生产环境打包时，会生成不同的hash值。")]),v._v(" "),t("p",[v._v("由于index.html文件不会被缓存，所以该文件中引入的js文件即时打包生成带有最新的hash值的js。所以请求会指向新的URI，不会走缓存。")]),v._v(" "),t("h3",{attrs:{id:"常见问题总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见问题总结"}},[v._v("#")]),v._v(" 常见问题总结")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("缓存设置操作只能在服务器端进行，客户端浏览器能做什么？")]),v._v(" "),t("p",[v._v("前端并不能做什么。缓存这件事，让服务器端去搞。")])]),v._v(" "),t("li",[t("p",[v._v("首页index.html即使没有加hash戳也是不会被缓存的，防止出现断网时仍能访问页面的情况")])]),v._v(" "),t("li",[t("p",[v._v("浏览器network上，有一个小按钮，可以禁用所有缓存")])]),v._v(" "),t("li",[t("p",[v._v("关于 "),t("code",[v._v("Cache-Control")]),v._v(" 响应头的值，当服务器设置为 "),t("code",[v._v("no-cache")]),v._v(" 时，代表每次请求会都访问服务器，但是也会走缓存。当值为 "),t("code",[v._v("no-store")]),v._v(" 才表示所有的请求，都不会走缓存")])]),v._v(" "),t("li",[t("p",[v._v("在进行指纹缓存时，node服务器端多使用 "),t("code",[v._v("Crypto")]),v._v(" 第三方模块")])]),v._v(" "),t("li",[t("p",[v._v("服务器端设置各种响应头标识（"),t("code",[v._v("Last-Modified等")]),v._v("）当前文件最新状态，那客户端浏览器第二次发给服务器时，需要手动把这个标识设置到请求头吗？")]),v._v(" "),t("p",[v._v("不需要，浏览器会携带")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://user-images.githubusercontent.com/33987402/77244026-b13af700-6c4b-11ea-86e6-914e8e543caa.png",alt:"性能优化—http"}})])])}),[],!1,null,null,null);_.default=e.exports}}]);